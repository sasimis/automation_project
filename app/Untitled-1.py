    s = re.sub(r"\s{2,}", " ", s)    return s.strip()def connect_gsheet(sheet_id: str, creds_path: Optional[str] = None, creds_dict: Optional[dict] = None):    """Connect to Google Sheets"""    import gspread    if creds_dict:        return gspread.service_account_from_dict(creds_dict).open_by_key(sheet_id)    elif creds_path:        return gspread.service_account(filename=creds_path).open_by_key(sheet_id)    return gspread.service_account().open_by_key(sheet_id)def upsert_worksheet(sh, title: str, rows: int = 1000, cols: int = 20):    """Get or create worksheet"""    try:        return sh.worksheet(title)    except Exception:        return sh.add_worksheet(title=title, rows=rows, cols=cols)# --- Money parsing helpers (EU/US aware) for EMAILS ---def eu_to_float(x):    """'€1.054,00' | '5.208,00' | '1,234.56' -> float; invalid -> <NA>."""    if x is None or x == "" and  type(x) is str:                return pd.NA    s = str(x)    raw = re.sub(r"[^\d,.\-+]", "", s)    if raw.count(",") >= 1 and raw.count(".") >= 1:        raw = raw.replace(".", "").replace(",", ".")     # 5.208,00 -> 5208.00    elif raw.count(",") == 1 and raw.count(".") == 0:        raw = raw.replace(",", ".")                      # 850,00 -> 850.00    elif raw.count(".") >= 1 and raw.count(",") == 0:        if re.fullmatch(r"\d{1,3}(?:\.\d{3})+", raw):            raw = raw.replace(".", "")                   # 5.208 -> 5208    try:        return float(raw)    except Exception:        return pd.NAdef extract_money_from_text(text: str):    """    Look for net/amount, VAT (amount or %), and total in Greek/English emails.    Returns dict with floats (or <NA>) and a flag if VAT is a rate.    """    pat = {        "amount": r"(?:Καθαρή\s*Αξία|Net|Subtotal)\s*[:\-]?\s*([€\d\.,]+)",        "vat":    r"(?:\bΦΠΑ\b[^:\n]*|VAT|Tax)\s*[:\-]?\s*([€\d\.,%]+)",        "total":  r"(?:ΣΥΝΟΛΟ|Σύνολο|Συνολικό\s*Ποσό|Total|Grand\s*Total)\s*[:\-]?\s*([€\d\.,]+)",    }    def find1(key):        m = re.search(pat[key], text, flags=re.IGNORECASE)        return m.group(1).strip() if m else ""    raw_amount = find1("amount")    raw_vat    = find1("vat")    raw_total  = find1("total")    amount = eu_to_float(raw_amount)    total  = eu_to_float(raw_total)    # VAT can be % or € amount    vat_amount = pd.NA    vat_rate   = pd.NA    if raw_vat:        m_pct = re.search(r"(\d+(?:[.,]\d+)?)\s*%", raw_vat)        if m_pct:            vat_rate = eu_to_float(m_pct.group(1))        else:            vat_amount = eu_to_float(raw_vat)    # reconcile missing value    if pd.notna(vat_rate) and pd.notna(amount):        vat_amount = round(amount * (vat_rate/100.0), 2)        if pd.isna(total):            total = round(amount + vat_amount, 2)    elif pd.notna(vat_amount) and pd.notna(amount) and pd.isna(total):        total = round(amount + vat_amount, 2)    elif pd.notna(total) and pd.notna(amount) and pd.isna(vat_amount):        vat_amount = round(total - amount, 2)    return {        "amount": amount,        "vat": vat_amount if pd.notna(vat_amount) else vat_rate,  # prefer amount; else store % rate        "total_amount": total,        "vat_is_rate": pd.isna(vat_amount) and pd.notna(vat_rate),    }# ===================== Email Parsing =====================GREEK_FIELD_PATTERNS = {    "name": r"^\s*-\s*(?:Όνομα|Ονομα|Όνομα και Επώνυμο)\s*:\s*(.+)$",    "email": r"^\s*-\s*Email\s*:\s*(.+)$",    "phone": r"^\s*-\s*(?:Τηλέφωνο|Τηλ)\s*:\s*(.+)$",    "company": r"^\s*-\s*(?:Εταιρεία|Company)\s*:\s*(.+)$",    "position": r"^\s*-\s*(?:Θέση|Position)\s*:\s*(.+)$",}def _extract_content(msg) -> Tuple[str, bool]:    """Extract content from email, preferring HTML if available"""    html_content = plain_content = ""        if msg.is_multipart():        for part in msg.walk():            ctype = part.get_content_type()            charset = part.get_content_charset() or "utf-8"            payload = part.get_payload(decode=True) or b""                        try:                decoded = payload.decode(charset, errors="replace")            except UnicodeDecodeError:                decoded = payload.decode("latin-1", errors="replace")                            if ctype == "text/plain":                plain_content = decoded.strip()            elif ctype == "text/html":                html_content = decoded.strip()    else:        ctype = msg.get_content_type()        charset = msg.get_content_charset() or "utf-8"        payload = msg.get_payload(decode=True) or b""        try:            decoded = payload.decode(charset, errors="replace")        except UnicodeDecodeError:            decoded = payload.decode("latin-1", errors="replace")                    if ctype == "text/plain":            plain_content = decoded.strip()        elif ctype == "text/html":            html_content = decoded.strip()        return (html_content, True) if html_content else (plain_content, False)def parse_eml(path: Path) -> Dict[str, str]:    """Parse .eml file into structured data"""    with path.open("rb") as f:        msg = BytesParser(policy=policy.default).parse(f)    content, is_html = _extract_content(msg)    lines = [l for l in content.split("\n") if l.strip()] if not is_html else []        data = {        "type": "EMAIL",        "source": path.name,        "source_path": str(path),        "from_name": sanitize_field(msg.get("From")),        "to": sanitize_field(msg.get("To")),        "subject": sanitize_field(msg.get("Subject")),        "date_raw": sanitize_field(msg.get("Date")),        "name": "",        "email": "",        "phone": "",        "company": "",        "service_interest": "",        "amount": "",        "vat": "",        "total_amount": "",        "invoice_number": "",        "priority": "",        "message": content,        "is_html": is_html    }        # Parse date    try:        dt = dateparse.parse(data["date_raw"])        data["date"] = dt.date().isoformat() if dt else ""    except Exception:        data["date"] = ""    # Extract labeled fields    for line in lines:        for key, pattern in GREEK_FIELD_PATTERNS.items():            m = re.search(pattern, line, flags=re.IGNORECASE)            if m and not data.get(key):                data[key] = sanitize_field(m.group(1))    # Detect service interest    lower_body = content.lower()    if re.search(r"\bcrm\b", lower_body):        data["service_interest"] = "CRM"    elif re.search(r"\berp\b", lower_body):        data["service_interest"] = "ERP Integration"    elif re.search(r"\bwebsite\b", lower_body):        data["service_interest"] = "Website"        # --- Add this block to extract invoice fields from email body ---    invoice_patterns = {        "amount": r"(?:Καθαρή Αξία|Net|Subtotal)[\s:]*([€\d\.,]+)",        "vat": r"(?:ΦΠΑ 24%|VAT|Tax)[\s:]*([€\d\.,]+)",